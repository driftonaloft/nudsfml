


    /**
     * Specify value for float uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		x		= Value of the float scalar
     */
     void setUniform(const(char)[] name, float x)
     {
        sfShader_setFloatUniform(sfPtr, name.toStringz, x);
     }

    ///ditto
    void opIndexAssign(float x, const(char)[] name)
    {
        setUniform(name, x);
    }

    /**
     * Specify value for vec2 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the vec2 vector
     */
    void setUniform(const(char)[] name, ref const(Vec2) vector)
    {
        sfShader_setVec2Uniform(sfPtr, name.ptr, name.length, &vector);
    }

    ///ditto
    void opIndexAssign(ref const(Vec2) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }

    /**
     * Specify value for vec3 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the vec3 vector
     */
    void setUniform(const(char)[] name, ref const(Vec3) vector)
    {
        sfShader_setVec3Uniform(sfPtr, name.ptr, name.length, &vector);
    }

    ///ditto
    void opIndexAssign(ref const(Vec3) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }

    /**
     * Specify value for vec4 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the vec4 vector
     */
    void setUniform(const(char)[] name, ref const(Vec4) vector)
    {
        sfShader_setVec4Uniform(sfPtr, name.ptr, name.length, &vector);
    }

    ///ditto
    void opIndexAssign(ref const(Vec4) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }

    /**
     * Specify value for int uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		x		= Value of the int scalar
     */
     void setUniform(const(char)[] name, int x)
     {
        sfShader_setIntUniform(sfPtr, name.ptr, name.length, x);
     }

    ///ditto
    void opIndexAssign(int x, const(char)[] name)
    {
        setUniform(name, x);
    }

    /**
     * Specify value for ivec2 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the ivec2 vector
     */
    void setUniform(const(char)[] name, ref const(Ivec2) vector)
    {
        sfShader_setIvec2Uniform(sfPtr, name.ptr, name.length, &vector);
    }

    ///ditto
    void opIndexAssign(ref const(Ivec2) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }

    /**
     * Specify value for ivec3 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the ivec3 vector
     */
    void setUniform(const(char)[] name, ref const(Ivec3) vector)
    {
        sfShader_setIvec3Uniform(sfPtr, name.ptr, name.length, &vector);
    }

    ///ditto
    void opIndexAssign(ref const(Ivec3) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }

    /**
     * Specify value for ivec4 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the ivec4 vector
     */
    void setUniform(const(char)[] name, ref const(Ivec4) vector)
    {
        sfShader_setIvec4Uniform(sfPtr, name.ptr, name.length, &vector);
    }

    ///ditto
    void opIndexAssign(ref const(Ivec4) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }

    /**
     * Specify value for bool uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		x		= Value of the bool scalar
     */
     void setUniform(const(char)[] name, bool x)
     {
        sfShader_setBoolUniform(sfPtr, name.ptr, name.length, x);
     }

     ///ditto
    void opIndexAssign(bool x, const(char)[] name)
    {
        setUniform(name, x);
    }

    /**
     * Specify value for bvec2 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the bvec2 vector
     */
    void setUniform(const(char)[] name, ref const(Bvec2) vector)
    {
        sfShader_setBvec2Uniform(sfPtr, name.ptr, name.length,
                                   vector.x, vector.y);
    }

    ///ditto
    void opIndexAssign(ref const(Bvec2) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }

    /**
     * Specify value for bvec3 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the bvec3 vector
     */
    void setUniform(const(char)[] name, ref const(Bvec3) vector)
    {
        sfShader_setBvec3Uniform(sfPtr, name.ptr, name.length, vector.x,
                                 vector.y, vector.z);
    }

    ///ditto
    void opIndexAssign(ref const(Bvec3) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }


    /**
     * Specify value for bvec4 uniform.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		vector	= Value of the bvec4 vector
     */
    void setUniform(const(char)[] name, ref const(Bvec4) vector)
    {
        sfShader_setBvec4Uniform(sfPtr, name.ptr, name.length, vector.x,
                                 vector.y, vector.z, vector.w);
    }

    ///ditto
    void opIndexAssign(ref const(Bvec4) vector, const(char)[] name)
    {
        setUniform(name, vector);
    }

    /**
     * Specify value for mat3 matrix.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		matrix	= Value of the mat3 vector
     */
    void setUniform(const(char)[] name, ref const(Mat3) matrix)
    {
        sfShader_setMat3Uniform(sfPtr, name.ptr, name.length, &matrix);
    }

    ///ditto
    void opIndexAssign(ref const(Mat3) matrix, const(char)[] name)
    {
        setUniform(name, matrix);
    }

    /**
     * Specify value for mat4 matrix.
     *
     * Params:
     * 		name	= Name of the uniform variable in GLSL
     * 		matrix	= Value of the mat4 vector
     */
    void setUniform(const(char)[] name, ref const(Mat4) matrix)
    {
        sfShader_setMat4Uniform(sfPtr, name.ptr, name.length, &matrix);
    }

    ///ditto
    void opIndexAssign(ref const(Mat4) matrix, const(char)[] name)
    {
        setUniform(name, matrix);
    }

    /**
     * Specify a texture as sampler2D uniform.
     *
     * 'name' is the name of the variable to change in the shader. The
     * corresponding parameter in the shader must be a 2D texture (sampler2D
     * GLSL type).
     *
     * It is important to note that texture must remain alive as long as the
     * shader uses it, no copy is made internally.
     *
     * To use the texture of the object being drawn, which cannot be known in
     * advance, you can pass the special value CurrentTexture.
     *
     * Params:
     * 		name	= Name of the texture in the shader
     *		texture	= Texture to assign
     */
    void setUniform(const(char)[] name, const(Texture) texture)
    {
        sfShader_setTextureUniform(sfPtr, name.ptr, name.length,
                                   texture?texture.sfPtr:null);
    }

    ///ditto
    void opIndexAssign(const(Texture) texture, const(char)[] name)
    {
        sfShader_setTextureUniform(sfPtr, name.ptr, name.length,
                                   texture?texture.sfPtr:null);
    }

    /**
     * Specify current texture as sampler2D uniform.
     *
     * This overload maps a shader texture variable to the texture of the object
     * being drawn, which cannot be known in advance. The second argument must
     * be CurrentTexture. The corresponding parameter in the shader must be a 2D
     * texture (sampler2D GLSL type).
     *
     * Params:
     * 		name	= Name of the texture in the shader
     */
    void setUniform(const(char)[] name, CurrentTextureType)
    {
        sfShader_setCurrentTextureUniform(sfPtr, name.ptr, name.length);
    }

    ///ditto
    void opIndexAssign(CurrentTextureType, const(char)[] name)
    {
        sfShader_setCurrentTextureUniform(sfPtr, name.ptr, name.length);
    }

    /**
     * Specify values for float[] array uniform.
     *
     * Params:
     *		name		= Name of the uniform variable in GLSL
     *		scalarArray = array of float values
     */
    void setUniformArray(const(char)[] name, const(float)[] scalarArray)
    {
        sfShader_setFloatArrayUniform(sfPtr, name.ptr, name.length,
                                      scalarArray.ptr, scalarArray.length);
    }

    ///ditto
    void opIndexAssign(const(float)[] scalars, const(char)[] name)
    {
        setUniformArray(name, scalars);
    }

    /**
     * Specify values for vec2[] array uniform.
     *
     * Params:
     *		name		= Name of the uniform variable in GLSL
     *		vectorArray = array of vec2 values
     */
    void setUniformArray(const(char)[] name, const(Vec2)[] vectorArray)
    {
        sfShader_setVec2ArrayUniform(sfPtr, name.ptr, name.length,
                                     vectorArray.ptr, vectorArray.length);
    }

    ///ditto
    void opIndexAssign(const(Vec2)[] vectors, const(char)[] name)
    {
        setUniformArray(name, vectors);
    }

    /**
     * Specify values for vec3[] array uniform.
     *
     * Params:
     *		name		= Name of the uniform variable in GLSL
     *		vectorArray = array of vec3 values
     */
    void setUniformArray(const(char)[] name, const(Vec3)[] vectorArray)
    {
        sfShader_setVec3ArrayUniform(sfPtr, name.ptr, name.length,
                                     vectorArray.ptr, vectorArray.length);
    }

    ///ditto
    void opIndexAssign(const(Vec3)[] vectors, const(char)[] name)
    {
        setUniformArray(name, vectors);
    }

    /**
     * Specify values for vec4[] array uniform.
     *
     * Params:
     *		name		= Name of the uniform variable in GLSL
     *		vectorArray = array of vec4 values
     */
    void setUniformArray(const(char)[] name, const(Vec4)[] vectorArray)
    {
        sfShader_setVec4ArrayUniform(sfPtr, name.ptr, name.length,
                                     vectorArray.ptr, vectorArray.length);
    }

    ///ditto
    void opIndexAssign(const(Vec4)[] vectors, const(char)[] name)
    {
        setUniformArray(name, vectors);
    }

    /**
     * Specify values for mat3[] array uniform.
     *
     * Params:
     *		name		= Name of the uniform variable in GLSL
     *		matrixArray = array of mat3 values
     */
    void setUniformArray(const(char)[] name, const(Mat3)[] matrixArray)
    {
        sfShader_setMat3ArrayUniform(sfPtr, name.ptr, name.length,
                                     matrixArray.ptr, matrixArray.length);
    }

    ///ditto
    void opIndexAssign(const(Mat3)[] matrices, const(char)[] name)
    {
        setUniformArray(name, matrices);
    }

    /**
     * Specify values for mat4[] array uniform.
     *
     * Params:
     *		name		= Name of the uniform variable in GLSL
     *		matrixArray = array of mat4 values
     */
    void setUniformArray(const(char)[] name, const(Mat4)[] matrixArray)
    {
        sfShader_setMat4ArrayUniform(sfPtr, name.ptr, name.length,
                                     matrixArray.ptr, matrixArray.length);
    }

    ///ditto
    void opIndexAssign(const(Mat4)[] matrices, const(char)[] name)
    {
        setUniformArray(name, matrices);
    }

    /**
     * Change a float parameter of the shader.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader. The corresponding parameter in the shader must be a float (float GLSL type).
     * 		x		= Value to assign
     */
    deprecated("Use setUniform(const(char)[], float) instead.")
    void setParameter(const(char)[] name, float x)
    {
        import dsfml.system.string;
        sfShader_setFloatParameter(sfPtr, name.ptr, name.length, x);
    }

    /**
     * Change a 2-components vector parameter of the shader.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader. The corresponding parameter in the shader must be a 2x1 vector (vec2 GLSL type).
     * 		x		= First component of the value to assign
     * 		y		= Second component of the value to assign
     */
    deprecated("Use setUniform(const(char)[] , ref const(Vec2)) instead.")
    void setParameter(const(char)[] name, float x, float y)
    {
        import dsfml.system.string;
        sfShader_setFloat2Parameter(sfPtr, name.ptr, name.length, x, y);
    }

    /**
     * Change a 3-components vector parameter of the shader.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader. The corresponding parameter in the shader must be a 3x1 vector (vec3 GLSL type).
     * 		x		= First component of the value to assign
     * 		y		= Second component of the value to assign
     * 		z		= Third component of the value to assign
     */
    deprecated("Use setUniform(const(char)[] , ref const(Vec3)) instead.")
    void setParameter(const(char)[] name, float x, float y, float z)
    {
        import dsfml.system.string;
        sfShader_setFloat3Parameter(sfPtr, name.ptr, name.length, x,y,z);
    }

    /**
     * Change a 4-components vector parameter of the shader.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader. The corresponding parameter in the shader must be a 4x1 vector (vec4 GLSL type).
     * 		x		= First component of the value to assign
     * 		y		= Second component of the value to assign
     * 		z		= Third component of the value to assign
     * 		w		= Fourth component of the value to assign
     */
    deprecated("Use setUniform(const(char)[] , ref const(Vec4)) instead.")
    void setParameter(const(char)[] name, float x, float y, float z, float w)
    {
        import dsfml.system.string;
        sfShader_setFloat4Parameter(sfPtr, name.ptr, name.length, x, y, z, w);
    }

    /**
     * Change a 2-components vector parameter of the shader.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader. The corresponding parameter in the shader must be a 2x1 vector (vec2 GLSL type).
     * 		vector	= Vector to assign
     */
    deprecated("Use setUniform(const(char)[] , ref const(Vec2)) instead.")
    void setParameter(const(char)[] name, Vector2f vector)
    {
        import dsfml.system.string;
        sfShader_setFloat2Parameter(sfPtr, name.ptr, name.length, vector.x, vector.y);
    }

    /**
     * Change a 3-components vector parameter of the shader.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader.
     *                The corresponding parameter in the shader must be a 3x1
                      vector (vec3 GLSL type)
     * 		vector	= Vector to assign
     */
    deprecated("Use setUniform(const(char)[] , ref const(Vec3)) instead.")
    void setParameter(const(char)[] name, Vector3f vector)
    {
        import dsfml.system.string;
        sfShader_setFloat3Parameter(sfPtr, name.ptr, name.length, vector.x, vector.y, vector.z);
    }

    /**
     * Change a color vector parameter of the shader.
     *
     * It is important to note that the components of the color are normalized
     * before being passed to the shader. Therefore, they are converted from
     * range [0 .. 255] to range [0 .. 1]. For example, a
     * Color(255, 125, 0, 255) will be transformed to a vec4(1.0, 0.5, 0.0, 1.0)
     * in the shader.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader. The
     *                corresponding parameter in the shader must be a 4x1 vector
     *                (vec4 GLSL type).
     * 		color	= Color to assign
     */
    deprecated("Use setUniform(const(char)[] , ref const(Vec4)) instead.")
    void setParameter(const(char)[] name, Color color)
    {
        import dsfml.system.string;
        sfShader_setColorParameter(sfPtr, name.ptr, name.length, color.r, color.g, color.b, color.a);
    }

    ///ditto
    deprecated("Use shader[\"name\"] = Vec4(color) instead.")
    void opIndexAssign(Color color, const(char)[] name)
    {
        import dsfml.system.string;
        sfShader_setColorParameter(sfPtr, name.ptr, name.length, color.r, color.g, color.b, color.a);
    }

    /**
     * Change a matrix parameter of the shader.
     *
     * Params:
     * 		name		= The name of the variable to change in the shader. The
     *                    corresponding parameter in the shader must be a 4x4
                          matrix (mat4 GLSL type)
     * 		transform	= Transform to assign
     */
    deprecated("Use setUniform(const(char)[] , ref const(Mat4)) instead.")
    void setParameter(const(char)[] name, Transform transform)
    {
        import dsfml.system.string;
        sfShader_setTransformParameter(sfPtr, name.ptr, name.length, transform.m_matrix.ptr);
    }

    ///ditto
    deprecated("Use shader[\"name\"] = Mat4(transform) instead.")
    void opIndexAssign(Transform transform, const(char)[] name)
    {
        import dsfml.system.string;
        sfShader_setTransformParameter(sfPtr, name.ptr, name.length, transform.m_matrix.ptr);
    }

    /**
     * Change a texture parameter of the shader.
     *
     * It is important to note that the texture parameter must remain alive as
     * long as the shader uses it - no copoy is made internally.
     *
     * To use the texture of the object being draw, which cannot be known in
     * advance, you can pass the special value Shader.CurrentTexture.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader. The
     *                corresponding parameter in the shader must be a 2D texture
     *                (sampler2D GLSL type)
     * 		texture	= Texture to assign
     */
    deprecated("Use setUniform(const(char)[] , const(Texture)) instead.")
    void setParameter(const(char)[] name, const(Texture) texture)
    {
        sfShader_setTextureParameter(sfPtr, name.ptr, name.length, texture?texture.sfPtr:null);
    }

    /**
     * Change a texture parameter of the shader.
     *
     * This overload maps a shader texture variable to the texture of the object
     * being drawn, which cannot be known in advance. The second argument must
     * be Shader.CurrentTexture.
     *
     * Params:
     * 		name	= The name of the variable to change in the shader.
     *                The corresponding parameter in the shader must be a 2D texture
     *                (sampler2D GLSL type)
     *      currentTexture = Dummy variable to denote the texture of the object
     */
    deprecated("Use setUniform(const(char)[] , CurrentTextureType) instead.")
    void setParameter(const(char)[] name, CurrentTextureType currentTexture)
    {
        import dsfml.system.string;
        sfShader_setCurrentTextureParameter(sfPtr, name.ptr, name.length);
    }

    /**
     * Bind a shader for rendering.
     *
     * This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix Shader with OpenGL code.
     *
     * Params:
     * 		shader	= Shader to bind. Can be null to use no shader.
     */
    static void bind(Shader shader)
    {
        (shader is null)?sfShader_bind(null):sfShader_bind(shader.sfPtr);
    }

    /**
     * Tell whether or not the system supports shaders.
     *
     * This function should always be called before using the shader features.
     * If it returns false, then any attempt to use DSFML Shader will fail.
     *
     * Returns: true if shaders are supported, false otherwise.
     */
    static bool isAvailable()
    {
        return sfShader_isAvailable();
    }

    /**
     * Tell whether or not the system supports geometry shaders.
     *
     * Returns: true if geometry shaders are supported, false otherwise.
     */
    static bool isGeometryAvailable()
    {
        return sfShader_isGeometryAvailable();
    }